<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Recorder</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #f0f2f5;
            position: relative;
        }

        #localVideo {
            width: 70%;
            max-width: 950px;
            border-radius: 10px;
            background: #000;
            transform: scaleX(-1); /* Mirror flip */
        }

        .controls {
            margin: 25px 0;
            display: flex;
            gap: 15px;
        }

        .button {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.3em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .mic-btn { background: #3cba54; } /* Green */
        .camera-btn { background: #4285f4; } /* Blue */
        .flip-btn { background: #737373; } /* Gray */
        .end-call { background: #db4437; } /* Red */
        
        .text-field {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            border: 2px solid #cccccc00;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0); /* Lowered opacity */
            text-align: center;
            color:#f0f2f5;
            width: 42%;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <video id="localVideo" autoplay muted></video>
        <div class="controls">
            <button class="button mic-btn" id="micButton">
                <i class="fas fa-microphone"></i>
            </button>
            <button class="button camera-btn" id="cameraButton">
                <i class="fas fa-video"></i>
            </button>
            <button class="button flip-btn" id="flipButton">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button class="button end-call" id="endCall">
                <i class="fas fa-phone-slash"></i>
            </button>
            <label class="switch">
                <input type="checkbox" id="transcriptionSwitch" onclick="toggleTranscription()">
                <span class="slider"></span>
            </label>
        </div>
        <div class="question"></div>
    </div>

    <script>
        //Interview
        let currentQuestionNumber = null; // Initialize with no question number
        let isTranscribing = false;

        // Toggle transcription on/off
        function toggleTranscription() {
            isTranscribing = !isTranscribing;
            if (isTranscribing) {
                startTranscription();
            } else {
                stopTranscription();
            }
        }

        // Start transcription for the current question
        function startTranscription() {
            if (currentQuestionNumber === null) {
                console.error("No question available for transcription.");
                return;
            }

            fetch(`/start_transcription/?question_number=${currentQuestionNumber}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('result').innerText = data.status;
                    fetchTranscription();
                })
                .catch(error => {
                    console.error('Error starting transcription:', error);
                    document.getElementById('result').innerText = "Error starting transcription.";
                });
        }

        // Stop transcription for the current question
        function stopTranscription() {
            if (currentQuestionNumber === null) {
                console.error("No question available to stop transcription.");
                return;
            }

            fetch(`/interview/stop_transcription/?question_number=${currentQuestionNumber}`)
                .then(response => response.json())
                .then(data => {
                    if (data.response && data.score !== undefined) {
                        document.getElementById('result').innerText = `Response: ${data.response}\nScore: ${data.score}`;
                    } else {
                        document.getElementById('result').innerText = "Error with transcription data.";
                    }
                    nextQuestion();  // Automatically move to the next question
                })
                .catch(error => {
                    console.error('Error stopping transcription:', error);
                    document.getElementById('result').innerText = "Error stopping transcription.";
                });
        }

        // Fetch live transcription updates
        function fetchTranscription() {
            if (isTranscribing) {
                fetch('/interview/live_transcribe/')
                    .then(response => response.json())
                    .then(data => {
                        if (data.transcription) {
                            document.getElementById('result').innerText += ` ${data.transcription}`;
                        } else if (data.error) {
                            console.error('Error in transcription:', data.error);
                        }

                        if (isTranscribing) {
                            setTimeout(fetchTranscription, 1000); // Poll every second
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching live transcription:', error);
                    });
            }
        }

        // Fetch the question based on the current question number
        function fetchQuestion(questionNumber = null) {
            let url = questionNumber ? `/interview/get_question/?question_number=${questionNumber}` : `/interview/get_question/`; // Fetch first question if no number
            console.log("Fetching question from:", url);
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById('question').innerText = "No more questions available.";
                        return;
                    }

                    document.getElementById('question').innerText = data.question_text;
                    currentQuestionNumber = data.question_number; // Update current question number
                    console.log("Current Question Number:", currentQuestionNumber);
                })
                .catch(error => {
                    console.error('Error fetching question:', error);
                    document.getElementById('question').innerText = "Error fetching question.";
                });
        }

        // Move to the next question
        function nextQuestion() {
            if (currentQuestionNumber === null) {
                console.error("No current question to move forward from.");
                return;
            }

            fetch(`/interview/stop_transcription/?question_number=${currentQuestionNumber}`)
                .then(response => response.json())
                .then(data => {
                    if (data.next_question_number) {
                        fetchQuestion(data.next_question_number); // Fetch next question dynamically
                        console.log(data.next_question_number);
                    } else {
                        document.getElementById('question').innerText = "Okay, the questions are finished. You can exit the interview.";
                    }

                    document.getElementById('result').innerText = ""; // Clear previous result
                })
                .catch(error => {
                    console.error('Error fetching next question:', error);
                });
        }

        // Fetch the first question when the page loads
        window.onload = function () {
            fetchQuestion(); // Start by fetching the first question
        };
        
        
        
        // Interview
        let mediaStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isMicOn = true;
        let isCameraOn = true;
        let isFrontCamera = true;

        const mimeTypeOptions = [
            'video/webm;codecs=vp9,opus',
            'video/webm;codecs=vp8,opus',
            'video/webm'
        ];

        async function initializeMedia() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: isFrontCamera ? "user" : "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                });

                const videoElement = document.getElementById('localVideo');
                videoElement.srcObject = mediaStream;

                const supportedMimeType = mimeTypeOptions.find(type => 
                    MediaRecorder.isTypeSupported(type)
                ) || 'video/webm';

                mediaRecorder = new MediaRecorder(mediaStream, {
                    mimeType: supportedMimeType,
                    audioBitsPerSecond: 128000,
                    videoBitsPerSecond: 2500000
                });

                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) recordedChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `recording-${Date.now()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        recordedChunks = [];
                    }, 100);
                };

                mediaRecorder.start(1000);

            } catch (error) {
                alert('Camera and microphone access required!');
            }
        }

        async function flipCamera() {
            try {
                mediaStream.getTracks().forEach(track => track.stop());
                isFrontCamera = !isFrontCamera;
                
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: isFrontCamera ? "user" : "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                });

                const videoElement = document.getElementById('localVideo');
                videoElement.srcObject = mediaStream;
                mediaStream.getVideoTracks()[0].enabled = isCameraOn;

                if (mediaRecorder?.state === 'recording') {
                    mediaRecorder.stop();
                    mediaRecorder = new MediaRecorder(mediaStream, {
                        mimeType: mediaRecorder.mimeType,
                        audioBitsPerSecond: 128000,
                        videoBitsPerSecond: 2500000
                    });
                    mediaRecorder.start(1000);
                }

            } catch (error) {
                console.error('Error flipping camera:', error);
            }
        }

        function toggleMic() {
            isMicOn = !isMicOn;
            mediaStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
            document.getElementById('micButton').innerHTML = 
                `<i class="fas fa-microphone${isMicOn ? '' : '-slash'}"></i>`;
        }

        function toggleCamera() {
            isCameraOn = !isCameraOn;
            mediaStream.getVideoTracks().forEach(track => track.enabled = isCameraOn);
            document.getElementById('cameraButton').innerHTML = 
                `<i class="fas fa-video${isCameraOn ? '' : '-slash'}"></i>`;
        }

        function endCall() {
            if (mediaRecorder?.state === 'recording') mediaRecorder.stop();
            mediaStream?.getTracks().forEach(track => track.stop());
        }

        // Event listeners
        document.getElementById('micButton').addEventListener('click', toggleMic);
        document.getElementById('cameraButton').addEventListener('click', toggleCamera);
        document.getElementById('flipButton').addEventListener('click', flipCamera);
        document.getElementById('endCall').addEventListener('click', endCall);

        // Initialize
        window.addEventListener('load', initializeMedia);
    </script>
</body>
</html>
